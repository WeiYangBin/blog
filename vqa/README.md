---
title: NodeJS模块加载机制
---
# NodeJS模块加载机制
讲NodeJS模块的加载机制前，我们先来讲讲js模块化。

js与生俱来便缺少模块化的东西，以至于前辈们在构建网站时很是头疼，自己构建时，往往要自己区分作用域，使用闭包或者对象管理各个模块；引入第三方模块时没有通用的模块化规范，只能手动嵌入<script></script>，并且要管理好前后的依赖；捂心心疼一秒......

所以促进js模块化与模块化统一规范发展迫在眉睫。2009年NodeJS的出现，这标志"Javascript模块化编程"正式诞生。NodeJS的模块化就是参照CommonJS规范实现的，CommonJS规范主要用在服务端。比较出名用在浏览器端的AMD规范。ES6在CommonJS基础上则推出静态化的模块化机制，使之编译时就能确定模块之间的依赖关系。

好的，规范出来了，那么支持这些规范的工具也随着而来了，在NodeJS环境支持下，webpack模块化打包工具乘势席卷了前端圈。好的，接下来回到主角，NodeJS模块加载机制

#### 一、贴出CommonJS的模块规范

1、模块引用

```js
const element = require('element-ui')
```
2、导出模块定义

```js
// 导出默认模块
module.exports = 'element-ui'
// 导出具名模块
exports.ElInput = 'el-input'
```
3、模块标识

可以是符合小驼峰命名的字符串或者是相对路径与绝对路径

**在CommonJS模块中，有三个变量，module（代表模块本身)，exports(导出对象)，require（引入模块方法）**
#### 二、NodeJS的模块加载机制
在node中引入模块需要经历三个步骤：
- 路径分析
- 文件定位
- 编译执行

在node中，模块分为两类：核心模块和文件模块，核心模块在node启动时就被写入内存中，省去了文件定位和编译执行
##### 1、 优先从缓存加载
也就是用require（）加载过的，会缓存，下次优先从缓存加载，这也是为什么我们使用webpack构建项目时，为什么第一次构建的时间会慢于第二次构建的原因
##### 2、路径分析和文件定位

- 路径形式文件模块，require（路径），指明了文件的具体位置，能够节约大量的时间
- 自定义模块，require（名字），这类模块查找最费时，它的查找策略是沿着当前node_modules目录逐层往上寻找，直到根目录下的node_modules，文件的路径越深查找越费时，加载越慢

查找到文件的路径，剩下文件的定位，require()在分析标识符的过程中可以不包含扩展名，node会按照.js、.json、.node的次序依次寻找

**所以为了加快加载速度，建议大家都使用路径定位文件且加上扩展名，减少node的加载时间**
##### 3、模块编译
- .js文件。通过fs模块同步读取文件后编译执行
- .node文件。通过dlopen()方法加载最后编译生成的文件
- .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回的结果
- 其余。全被当做.js文件载入，项目构建中require()后怎么识别，这就轮到webpack上手了
