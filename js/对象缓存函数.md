---
title: 对象缓存
---
## 一、解决问题
1. 避免重复运算
2. 避免重复创建对象
3. 优化代码计算量与运行性能

## 二、具体实现方式


```js
function toCache(fn) {
    let cache = {};
    return function() {
        //将实参转换为字符串的形式，将其用作cache的key
        let key = arguments.length + Array.prototype.join.call(arguments, ',');
        if (key in cache) return cache[key];
        return cache[key] = fn.apply(this, argunments);
    }
}
```

## 三、具体实例

1. 创建对象实例

```
function factory(opt) {
    return new NewObj(opt);
}

function NewObj(opt) {
    this.init(opt)
}

NewObj.prototype.init = function(opt) {
    Object.assign(this.opt, opt)
}

//缓存factory与cache
let mekeObj = toCache(factory);
//第一次创建对象
makeObj({a: 1, b: 2, c: 3});
//第二次创建对象
makeObj({a: 1, b: 2, c: 3})；
//当再次调用创建对象方法makeObj({a: 1, b: 2, c: 3})时，将会从cache中直接拿刚才创建好的对象
```

2. 计算缓存

```
function sum(a, b, c) {
    return a + b + c;
}

let cacheSum = toCache(sum);

//首次计算
cacheSum(1, 2, 3);

//再次计算,将会从cache中直接拿cache['1,2,3']，避免再次计算;
cacheSum(1, 2, 3);
```